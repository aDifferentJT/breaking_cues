#![feature(closure_lifetime_binder)]
#![feature(ptr_metadata)]

use core::marker::PhantomData;
use std::fs;
use std::future;
use std::path::Path;
use std::sync;
use std::sync::{Arc, LazyLock};

use include_dir::include_dir;

use futures::future::BoxFuture;
use futures::{FutureExt, SinkExt, StreamExt};

#[cfg(not(debug_assertions))]
use tauri::Manager;

const ASSETS: include_dir::Dir<'_> = include_dir!("$CARGO_MANIFEST_DIR/../dist");

struct Asset {
    pub bytes: Vec<u8>,
    pub mime_type: String,
    pub csp_header: Option<String>,
}

impl From<tauri::Asset> for Asset {
    fn from(
        tauri::Asset {
            bytes,
            mime_type,
            csp_header,
            ..
        }: tauri::Asset,
    ) -> Asset {
        Asset {
            bytes,
            mime_type,
            csp_header,
        }
    }
}

struct AssetResolver<R: tauri::Runtime> {
    #[cfg(not(debug_assertions))]
    asset_resolver: Arc<tauri::AssetResolver<R>>,

    #[cfg(debug_assertions)]
    frontend_dist: tauri_utils::config::FrontendDist,

    phantom: PhantomData<tauri::AssetResolver<R>>,
}

impl<R: tauri::Runtime> AssetResolver<R> {
    fn new(app: &tauri::App<R>) -> AssetResolver<R> {
        AssetResolver {
            #[cfg(not(debug_assertions))]
            asset_resolver: Arc::new(app.asset_resolver()),

            #[cfg(debug_assertions)]
            frontend_dist: app.config().build.frontend_dist.clone().unwrap(),

            phantom: PhantomData,
        }
    }

    fn get(&self, path: String) -> Option<Asset> {
        #[cfg(not(debug_assertions))]
        {
            self.asset_resolver.get(path).into()
        }

        #[cfg(debug_assertions)]
        {
            let path = Path::new(env!("CARGO_MANIFEST_DIR")).join(path);

            Some(Asset {
                bytes: fs::read(&path).ok()?,
                mime_type: mime_guess::from_path(&path).first_raw()?.to_owned(),
                csp_header: None,
            })
        }
    }
}

impl<R: tauri::Runtime> Clone for AssetResolver<R> {
    fn clone(&self) -> Self {
        AssetResolver {
            #[cfg(not(debug_assertions))]
            asset_resolver: self.asset_resolver.clone(),

            #[cfg(debug_assertions)]
            frontend_dist: self.frontend_dist.clone(),

            phantom: self.phantom,
        }
    }
}

fn asset_to_response(asset: Option<include_dir::File>) -> impl axum::response::IntoResponse {
    match asset {
        Some(file) => http::Response::builder()
            .status(http::StatusCode::OK)
            .header("Content-Type", file.mime_type)
            .header(
                "Content-Security-Policy",
                file.csp_header.unwrap_or_default(),
            )
            .body(axum::body::Body::from(file.bytes))
            .unwrap_or_else(|_| {
                http::Response::builder()
                    .status(http::StatusCode::INTERNAL_SERVER_ERROR)
                    .body(axum::body::Body::empty())
                    .unwrap()
            }),
        None => http::Response::builder()
            .status(http::StatusCode::NOT_FOUND)
            .body(axum::body::Body::empty())
            .unwrap(),
    }
}

struct StateUnsync<T> {
    state: T,
    fs: Vec<sync::Weak<dyn for<'a> Fn(&'a T) -> BoxFuture<'a, ()> + Send + Sync>>,
}

impl<T> StateUnsync<T> {
    fn new(state: T) -> Self {
        StateUnsync {
            state: state,
            fs: Vec::new(),
        }
    }

    async fn register(
        &mut self,
        f: &Arc<impl for<'a> Fn(&'a T) -> BoxFuture<'a, ()> + Send + Sync + 'static>,
    ) {
        {
            let f = Arc::downgrade(f);
            match self.fs.iter_mut().find(|x| x.strong_count() == 0) {
                Some(x) => *x = f,
                None => self.fs.push(f),
            }
        }
        f(&self.state).await;
    }

    async fn update(&mut self, new_state: T) {
        self.state = new_state;
        for f in &self.fs {
            if let Some(f) = f.upgrade() {
                f(&self.state).await;
            }
        }
    }
}

struct State<T> {
    state: parking_lot::Mutex<StateUnsync<T>>,
}

impl<T> State<T> {
    fn new(state: T) -> Self {
        State {
            state: parking_lot::Mutex::new(StateUnsync::new(state)),
        }
    }

    async fn register(
        &self,
        f: &Arc<impl for<'a> Fn(&'a T) -> BoxFuture<'a, ()> + Send + Sync + 'static>,
    ) {
        self.state.lock().register(f).await
    }

    async fn update(&self, new_state: T) {
        self.state.lock().update(new_state).await
    }
}

fn proxy() -> axum::routing::MethodRouter {
    use axum::extract::Query;
    use std::collections::HashMap;

    type Response = http::Response<reqwest::Body>;

    fn error(status: http::StatusCode, body: impl ToString) -> BoxFuture<'static, Response> {
        future::ready(
            http::Response::builder()
                .status(status)
                .header("Access-Control-Allow-Origin", "*")
                .body(body.to_string().into())
                .unwrap(),
        )
        .boxed()
    }

    axum::routing::get(
        move |Query(params): Query<HashMap<String, String>>,
              mut req: http::Request<axum::body::Body>| {
            match params.get("url") {
                Some(url) => match http::Uri::try_from(url) {
                    Ok(url) => {
                        *req.uri_mut() = url;
                        let headers = req.headers_mut();
                        headers.remove("host");
                        match reqwest::Request::try_from(
                            req.map(|body| reqwest::Body::wrap_stream(body.into_data_stream())),
                        ) {
                            Ok(req) => async move {
                                match reqwest::Client::new().execute(req).await {
                                    Ok(res) => {
                                        let mut res: http::Response<reqwest::Body> = res.into();
                                        res.headers_mut().insert(
                                            "Access-Control-Allow-Origin",
                                            http::HeaderValue::from_str("*").unwrap(),
                                        );
                                        res
                                    }
                                    Err(err) => {
                                        error(
                                            err.status()
                                                .unwrap_or(http::StatusCode::INTERNAL_SERVER_ERROR),
                                            err,
                                        )
                                        .await
                                    }
                                }
                            }
                            .boxed(),
                            Err(err) => error(http::StatusCode::BAD_REQUEST, err),
                        }
                    }
                    Err(err) => error(http::StatusCode::BAD_REQUEST, err),
                },
                None => error(http::StatusCode::BAD_REQUEST, ""),
            }
        },
    )
}

fn echo_ws(state: &'static State<String>) -> axum::routing::MethodRouter {
    axum::routing::get(|ws: axum::extract::ws::WebSocketUpgrade| async {
        ws.on_upgrade(|socket| async {
            let (sender, mut receiver) = socket.split();
            let sender = Arc::new(parking_lot::Mutex::new(sender));

            let send_handler = Arc::new(for<'a> move |msg: &'a String| -> BoxFuture<'a, ()> {
                let sender = sender.clone();
                async move {
                    match sender
                        .lock()
                        .send(axum::extract::ws::Message::Text(msg.clone()))
                        .await
                    {
                        Ok(()) => {}
                        Err(err) => println!("{err}"),
                    }
                }
                .boxed()
            });
            state.register(&send_handler).await;

            while let Some(Ok(msg)) = receiver.next().await {
                if let axum::extract::ws::Message::Text(msg) = msg {
                    state.update(msg).await;
                }
            }

            drop(send_handler); // Make sure it survives hereto
        })
    })
}

async fn serve(asset_resolver: AssetResolver<impl tauri::Runtime>) {
    let output_handler = || {
        let asset_resolver = asset_resolver.clone();
        move |path: &str| {
            let asset1 = ASSETS.get_file(path);
            let asset = asset_resolver.get("../dist/".to_owned() + path);
            future::ready(asset_to_response(asset))
        }
    };

    let app = axum::Router::new()
        .route(
            "/",
            axum::routing::get({
                let handler = output_handler();
                move || handler("output.html")
            }),
        )
        .route(
            "/*path",
            axum::routing::get({
                let handler = output_handler();
                move |axum::extract::Path(path): axum::extract::Path<String>| handler(&path)
            }),
        )
        .route("/proxy", proxy())
        .route(
            "/programme",
            echo_ws({
                static STATE: LazyLock<State<String>> = LazyLock::new(|| State::new("".to_owned()));
                &STATE
            }),
        )
        .route(
            "/live",
            echo_ws({
                static STATE: LazyLock<State<String>> = LazyLock::new(|| State::new("".to_owned()));
                &STATE
            }),
        );

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            tauri::async_runtime::spawn(serve(AssetResolver::new(app)));
            Ok(())
        })
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_fs::init())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
